<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Upload Product (Compressed Image)</title>
  <style>
    body { font-family: Arial, sans-serif; background:#f5f5f5; padding:20px; }
    .container { max-width:550px; margin:auto; background:#fff; padding:20px; border-radius:10px; box-shadow:0 2px 8px rgba(0,0,0,.08); }
    input, select, button { width:100%; padding:10px; margin:8px 0; border-radius:6px; border:1px solid #ccc; box-sizing:border-box; }
    button { background:#111; color:#fff; border:none; cursor:pointer; }
    .hint { font-size:13px; color:#555; }
    .success { color:green; font-weight:600; }
    .error { color:#b00020; font-weight:600; }
    img.preview { max-width:100%; border-radius:6px; margin-top:6px; }
  </style>
</head>
<body>
  <div class="container">
    <h2>Upload Product (with client-side image compression)</h2>

    <input id="name" placeholder="Product Name" />
    <select id="category">
      <option value="">Select Category</option>
      <option value="flower">Flower</option>
      <option value="animal">Animal</option>
      <option value="festive">Festive</option>
      <option value="special">Special</option>
      <option value="glassJar">Glass Jar</option>
    </select>
    <select id="waxType">
      <option value="soy" selected>Soy</option>
      <option value="gel">Gel</option>
    </select>
    <input id="weightGrams" type="number" placeholder="Weight (grams)" />
    <input id="burnTimeHours" type="text" placeholder="Burn Time (hours)" />
    <input id="price" type="number" placeholder="Price" />
    <input id="quantityPack" type="number" placeholder="Quantity Pack" />

    <select id="customizableFragrance">
      <option value="true">Customizable Fragrance: Yes</option>
      <option value="false">Customizable Fragrance: No</option>
    </select>

    <select id="customizableColor">
      <option value="true">Customizable Color: Yes</option>
      <option value="false">Customizable Color: No</option>
    </select>

    <label class="hint">Upload Image (will be resized & compressed):</label>
    <input id="imageUpload" type="file" accept="image/*" />
    <img id="preview" class="preview" style="display:none" />

    <input id="altText" placeholder="Alt Text" />

    <button id="uploadBtn">Upload Product</button>
    <p id="msg"></p>

    <p class="hint">Note: If compressed payload is still too large, the server will reject it (413). You can lower maxWidth / quality in the script below.</p>
  </div>

  <script>
/* Iterative compression + upload (replace your current script) */

// CONFIG — tune these
const START_MAX_WIDTH = 1200;
const START_MAX_HEIGHT = 1200;
const START_QUALITY = 0.7;
const MIN_QUALITY = 0.25;
const QUALITY_STEP = 0.1;       // how much to reduce quality each iteration
const SCALE_STEP = 0.85;        // scale down dimensions each iteration
const MAX_PAYLOAD_BYTES = 300000; // target max JSON size in bytes (~300 KB recommended)
const MAX_ITERATIONS = 8;

let compressedBase64 = "";
const input = document.getElementById('imageUpload');
const preview = document.getElementById('preview');
const msg = document.getElementById('msg');

input.addEventListener('change', async (e) => {
  const file = e.target.files && e.target.files[0];
  if (!file) return;
  if (file.size > 15 * 1024 * 1024) {
    msg.innerHTML = "<span class='error'>File >15MB. Choose smaller image.</span>";
    compressedBase64 = "";
    preview.style.display = 'none';
    return;
  }
  try {
    const img = await fileToImage(file);
    // compress iteratively to try to fit the payload
    const result = await compressIteratively(img, START_MAX_WIDTH, START_MAX_HEIGHT, START_QUALITY);
    if (!result) {
      compressedBase64 = "";
      preview.style.display = 'none';
      msg.innerHTML = "<span class='error'>Could not compress below desired size. Try choosing a smaller image.</span>";
      return;
    }
    compressedBase64 = result.dataUrl;
    preview.src = compressedBase64;
    preview.style.display = 'block';
    msg.innerHTML = `<span>Compressed image ~ ${(result.size/1024).toFixed(1)} KB (attempts: ${result.attempts})</span>`;
    console.log('Compressed bytes:', result.size);
  } catch (err) {
    console.error(err);
    msg.innerHTML = "<span class='error'>Image processing failed.</span>";
  }
});

document.getElementById('uploadBtn').addEventListener('click', async () => {
  msg.innerHTML = '';
  const uploadBtn = document.getElementById('uploadBtn');
  const originalBtnText = uploadBtn.textContent;

  if (!compressedBase64) {
    msg.innerHTML = "<span class='error'>Please upload an image first.</span>";
    return;
  }

  // Disable button and show loading
  uploadBtn.disabled = true;
  uploadBtn.textContent = 'Uploading...';
  uploadBtn.style.opacity = '0.6';
  uploadBtn.style.cursor = 'not-allowed';

  const burnTimeValue = document.getElementById('burnTimeHours').value.trim();
  const payload = {
    name: document.getElementById('name').value || 'Unnamed Product',
    category: document.getElementById('category').value || '',
    waxType: document.getElementById('waxType').value || '',
    weightGrams: Number(document.getElementById('weightGrams').value) || 0,
    price: Number(document.getElementById('price').value) || 0,
    quantityPack: Number(document.getElementById('quantityPack').value) || 1,
    customizableFragrance: document.getElementById('customizableFragrance').value === 'true',
    customizableColor: document.getElementById('customizableColor').value === 'true',
    imageUrl: compressedBase64,
    altText: document.getElementById('altText').value || '',
  };

  if (burnTimeValue) payload.burnTimeHours = burnTimeValue;

  const jsonStr = JSON.stringify(payload);
  const bytes = new TextEncoder().encode(jsonStr).length;
  console.log('Final JSON bytes:', bytes);

  if (bytes > MAX_PAYLOAD_BYTES) {
    msg.innerHTML = `<span class='error'>Payload too large (~${(bytes/1024).toFixed(0)} KB). Try a smaller image or use multipart upload.</span>`;
    uploadBtn.disabled = false;
    uploadBtn.textContent = originalBtnText;
    uploadBtn.style.opacity = '1';
    uploadBtn.style.cursor = 'pointer';
    return;
  }

  try {
    const res = await fetch('https://cozy-backend-1.onrender.com/api/products', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-admin-secret': 'super-secret-token'
      },
      body: jsonStr
    });

    const contentType = res.headers.get('Content-Type') || '';
    if (!res.ok) {
      let text = await res.text();
      msg.innerHTML = `<span class='error'>Upload failed: ${res.status} ${res.statusText}. Server message (first 300 chars): ${escapeHtml(text.slice(0,300))}</span>`;
      console.error('Server response:', text);
      return;
    }

    if (contentType.includes('application/json')) {
      const data = await res.json();
      msg.innerHTML = "<span class='success'>Product uploaded successfully ✔</span>";
      console.log('Server:', data);
      // optional: reset form as you had before
    } else {
      msg.innerHTML = "<span class='success'>Product uploaded (non-JSON response).</span>";
      console.log('Server response (non-json):', await res.text());
    }
  } catch (err) {
    console.error(err);
    msg.innerHTML = "<span class='error'>Request failed. See console for details.</span>";
  } finally {
    uploadBtn.disabled = false;
    uploadBtn.textContent = originalBtnText;
    uploadBtn.style.opacity = '1';
    uploadBtn.style.cursor = 'pointer';
  }
});

// --- Helpers: iterative compression logic ---
async function compressIteratively(img, startW, startH, startQuality) {
  let w = startW, h = startH, quality = startQuality;
  let attempts = 0;

  while (attempts < MAX_ITERATIONS) {
    attempts++;
    // draw to canvas
    const dataUrl = await compressImageToDataUrl(img, w, h, quality);
    const size = getBase64SizeBytes(dataUrl);
    // estimate full JSON size roughly: imageBytes + some small overhead (safe side)
    // JSON overhead approx length of other fields -> we'll estimate + 2000 bytes
    const estimatedTotal = size + 2000;
    if (estimatedTotal <= MAX_PAYLOAD_BYTES) {
      return { dataUrl, size, attempts };
    }
    // else reduce quality first, then scale down dimensions
    if (quality - QUALITY_STEP >= MIN_QUALITY) {
      quality = Math.max(MIN_QUALITY, quality - QUALITY_STEP);
    } else {
      // scale down dimensions
      w = Math.max(200, Math.round(w * SCALE_STEP));
      h = Math.max(200, Math.round(h * SCALE_STEP));
      // also drop quality to minimum floor
      quality = MIN_QUALITY;
    }
    // tiny safety delay to avoid blocking UI (not necessary but polite)
    await new Promise(r => setTimeout(r, 10));
  }
  // if we didn't fit
  return null;
}

function compressImageToDataUrl(img, maxW, maxH, quality) {
  return new Promise((resolve) => {
    let { width, height } = img;
    if (width > maxW || height > maxH) {
      const ratio = Math.min(maxW / width, maxH / height);
      width = Math.round(width * ratio);
      height = Math.round(height * ratio);
    }
    const canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    const ctx = canvas.getContext('2d');
    ctx.drawImage(img, 0, 0, width, height);
    // use JPEG (good compression)
    const dataUrl = canvas.toDataURL('image/jpeg', quality);
    resolve(dataUrl);
  });
}

// other helpers (reuse your functions)
function fileToImage(file) {
  return new Promise((resolve, reject) => {
    const url = URL.createObjectURL(file);
    const img = new Image();
    img.onload = () => { URL.revokeObjectURL(url); resolve(img); };
    img.onerror = (e) => reject(e);
    img.src = url;
  });
}

function getBase64SizeBytes(dataUrl) {
  const base64String = dataUrl.split(',')[1] || '';
  return Math.ceil(base64String.length * 3 / 4);
}

function escapeHtml(str) {
  return str.replace(/[&<>"'\/]/g, function (s) {
    return ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;','/':'&#x2F;'})[s];
  });
}
</script>

</body>
</html>
